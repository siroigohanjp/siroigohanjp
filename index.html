<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>タクティクス</title>
<style>
body {
    background-color: #1a1a1a;
    color: #fff;
    font-family: monospace;
    display: flex;
    margin: 0;
    padding: 10px;
    gap: 20px;
}
#titleScreen, #gameScreen {
    display: none;
    flex-direction: column;
    align-items: center;
}
#titleScreen.active, #gameScreen.active { display: flex; }
#gameContainer {
    display: flex;
    gap: 20px;
}
#map {
    display: grid;
    grid-template-columns: repeat(10, 25px);
    grid-template-rows: repeat(10, 25px);
    gap: 1px;
}
.cell {
    width: 25px;
    height: 25px;
    text-align: center;
    line-height: 25px;
    border: 1px solid #333;
    font-size: 12px;
    transition: background-color 0.2s;
}
.ally { color: #0f0; }
.enemy { color: #f00; }
.moveHighlight { background-color: rgba(0,255,0,0.3); }
.attackHighlight { background-color: rgba(255,0,0,0.3); }
#commandPanel { margin-top: 10px; display: flex; gap: 10px; }
button { padding: 5px 10px; }
#info { margin-top: 10px; }
#unitList {
    width: 200px;
}
.unitItem {
    margin-bottom: 5px;
}
.currentTurn { font-weight: bold; background-color: rgba(255,255,0,0.2); padding: 2px; }
.hpBar {
    display: inline-block;
    width: 60px;
    height: 8px;
    background-color: #333;
    margin-left: 5px;
    vertical-align: middle;
}
.hpFill {
    height: 100%;
    background-color: #f00;
}
</style>
</head>
<body>

<div id="titleScreen" class="active">
    <h1>タクティクス</h1>
    <button id="startBtn">始める</button>
</div>

<div id="gameScreen">
    <div id="gameContainer">
        <div>
            <div id="map"></div>
            <div id="commandPanel">
                <button id="moveBtn">移動</button>
                <button id="attackBtn">攻撃</button>
                <button id="endTurnBtn">終了</button>
            </div>
            <div id="info"></div>
        </div>
        <div id="unitList">
    <h3>キャラクターリスト</h3>
    <div id="unitsContainer"></div>
    <!-- ここにログを追加 -->
    <h3>ログ</h3>
    <div id="log" style="height:200px; overflow-y:auto; background:#222; padding:5px; font-size:12px;"></div>
</div>

    </div>
</div>

<script>
const classes = {
    'ナイト': {move:3, range:1, spd:4, atk:3, hp:30},
    '竜騎士': {move:3, range:2, spd:5, atk:3, hp:30},
    'アーチャー': {move:4, range:3, spd:6, atk:3, hp:30},
    '治癒士': {move:3, range:3, spd:3, atk:3, hp:30},
    '魔術士': {move:3, range:3, spd:2, atk:3, hp:30},
    '幻術士': {move:3, range:3, spd:1, atk:3, hp:30},
    'シーフ': {move:4, range:1, spd:7, atk:3, hp:30},
};

const mapSize = 10;
let map = [];
let units = [];
let turnOrder = [];
let currentUnitIndex = 0;
let selectedUnit = null;
let actionMode = null;


const moveBtn = document.getElementById('moveBtn');
const attackBtn = document.getElementById('attackBtn');
const endTurnBtn = document.getElementById('endTurnBtn');


function updateButtons() {
    if(!selectedUnit || selectedUnit.type !== 'ally') {
        moveBtn.disabled = true;
        attackBtn.disabled = true;
        endTurnBtn.disabled = true;
        return;
    }

    moveBtn.disabled = selectedUnit.hasMoved;
    attackBtn.disabled = selectedUnit.hasAttacked;
    endTurnBtn.disabled = false; // 終了ボタンは常に押せる
}



function createMap() {
    const mapDiv = document.getElementById('map');
    mapDiv.innerHTML = '';
    map = [];
    for (let y = 0; y < mapSize; y++) {
        const row = [];
        for (let x = 0; x < mapSize; x++) {
            const cell = document.createElement('div');
            cell.className = 'cell';
            cell.dataset.x = x;
            cell.dataset.y = y;
            mapDiv.appendChild(cell);
            row.push(null);
        }
        map.push(row);
    }
}

function placeUnits() {
    function getRandomEmpty() {
        while(true){
            const x = Math.floor(Math.random()*mapSize);
            const y = Math.floor(Math.random()*mapSize);
            if(!map[y][x]) return {x,y};
        }
    }

    units = [];
    for(let i=0;i<3;i++){
        let allyPos = getRandomEmpty();
        let enemyPos = getRandomEmpty();
        let allyClass = Object.keys(classes)[Math.floor(Math.random()*7)];
        let enemyClass = Object.keys(classes)[Math.floor(Math.random()*7)];
        let ally = {...classes[allyClass], type:'ally', name:allyClass, x:allyPos.x, y:allyPos.y, maxHp:classes[allyClass].hp};
        let enemy = {...classes[enemyClass], type:'enemy', name:enemyClass, x:enemyPos.x, y:enemyPos.y, maxHp:classes[enemyClass].hp};
        units.push(ally);
        units.push(enemy);
        map[ally.y][ally.x] = ally;
        map[enemy.y][enemy.x] = enemy;
    }
    turnOrder = [...units].sort((a,b)=>b.spd-a.spd);
    currentUnitIndex = 0;
}

function renderMap() {
    for(let y=0;y<mapSize;y++){
        for(let x=0;x<mapSize;x++){
            const cell = document.querySelector(`.cell[data-x='${x}'][data-y='${y}']`);
            const unit = map[y][x];
            cell.classList.remove('ally','enemy','moveHighlight','attackHighlight');
            if(unit){
                cell.textContent = unit.name[0];
                cell.classList.add(unit.type);
            } else { cell.textContent=''; }
        }
    }

    // 味方の場合のみハイライト
    if(selectedUnit && selectedUnit.type==='ally') {
        highlightMove(selectedUnit);
        highlightAttack(selectedUnit);
    }

    updateInfo();
    updateUnitList();
}

function updateInfo() {
    const info = document.getElementById('info');
    if(turnOrder.length===0) { info.innerHTML='全滅！'; return; }
    const unit = turnOrder[currentUnitIndex];
    info.innerHTML = `ターン: ${unit.name} (${unit.type}) HP:${unit.hp} <br> コマンドを選択してください`;
}

function updateUnitList(){
    const container = document.getElementById('unitsContainer');
    container.innerHTML='';
    turnOrder.forEach((unit, idx)=>{
        const div = document.createElement('div');
        div.className='unitItem';
        if(idx===currentUnitIndex) div.classList.add('currentTurn');
        
        let nameLabel = '';
        if(unit.type==='enemy'){
            nameLabel = `<span style="color:red;">敵　${unit.name}</span>`; // 敵の文字だけ赤くする
        } else {
            nameLabel = `　　${unit.name}`; // 味方はそのまま
        }

        div.innerHTML=`
            <span style="display:inline-block; width:120px; text-align:left;">${nameLabel}</span>
            HP: ${unit.hp}/${unit.maxHp}
        `;
        container.appendChild(div);
    });
}


function getMoveCost(unit, targetX, targetY) {
    const dx = Math.abs(unit.x - targetX);
    const dy = Math.abs(unit.y - targetY);

    if(dx === 0 || dy === 0) return dx + dy;  // 縦横
    else if(dx === dy) return dx * 2;         // 斜め
    else return Infinity; // L字移動は不可
}

function canMove(unit, targetX, targetY) {
    const dx = Math.abs(unit.x - targetX);
    const dy = Math.abs(unit.y - targetY);

    const cost = dx + dy; // 縦横のみ計算
    const targetCell = map[targetY][targetX];
    if(cost <= unit.move && (!targetCell || targetCell.type !== 'enemy')) return true;
    return false;
}





function highlightMove(unit){
    for(let y=0; y<mapSize; y++){
        for(let x=0; x<mapSize; x++){
            if(canMove(unit, x, y)) {
                const cell = document.querySelector(`.cell[data-x='${x}'][data-y='${y}']`);
                cell.classList.add('moveHighlight');
            }
        }
    }
}




function highlightAttack(unit){
    for(let y=0;y<mapSize;y++){
        for(let x=0;x<mapSize;x++){
            const target = map[y][x];
            if(target && target.type!==unit.type){
                if(Math.abs(unit.x-x)+Math.abs(unit.y-y)<=unit.range){
                    const cell = document.querySelector(`.cell[data-x='${x}'][data-y='${y}']`);
                    cell.classList.add('attackHighlight');
                }
            }
        }
    }
}

// 移動ボタン
document.getElementById('moveBtn').addEventListener('click', ()=>{
    if(!selectedUnit || selectedUnit.type!=='ally') return; // 味方以外は無効
    if(selectedUnit.hasMoved){ alert('移動はすでに行いました'); return; }
    actionMode='move';
});

// 攻撃ボタン
document.getElementById('attackBtn').addEventListener('click', ()=>{
    if(!selectedUnit || selectedUnit.type!=='ally') return; // 味方以外は無効
    if(selectedUnit.hasAttacked){ alert('攻撃はすでに行いました'); return; }
    actionMode='attack';
});

function moveUnit(unit, targetX, targetY) {
    if(unit.hasMoved) return false;

    if(!canMove(unit, targetX, targetY)) {
        addLog('移動範囲外または斜め不可');
        return false;
    }

    // 現在座標からターゲット座標まで移動（連続移動）
    map[unit.y][unit.x] = null;
    unit.x = targetX;
    unit.y = targetY;
    map[unit.y][unit.x] = unit;
    unit.hasMoved = true;
    addLog(`${unit.name}が (${targetX},${targetY}) に移動`);
    renderMap();
    updateButtons();
    return true;
}




function attackUnit(attacker, target){
    if(attacker.hasAttacked) return false;
    const dist = Math.abs(attacker.x-target.x)+Math.abs(attacker.y-target.y);
    if(dist>attacker.range){ alert('攻撃範囲外'); return false; }
    target.hp -= attacker.atk;
    attacker.hasAttacked = true;  // 攻撃済みに設定
    if(target.hp<=0){
    map[target.y][target.x]=null;
    units = units.filter(u=>u!==target);
    turnOrder = turnOrder.filter(u=>u!==target);
    addLog(`${target.name}を倒した！`);
} else {
    addLog(`${attacker.name}が${target.name}に${attacker.atk}ダメージ`);
}
    renderMap();
updateButtons(); // ここを追加
    return true;
}


function addLog(message){
    const logDiv = document.getElementById('log');
    const p = document.createElement('div');
    p.textContent = message;
    logDiv.appendChild(p);
    logDiv.scrollTop = logDiv.scrollHeight; // 自動スクロール
}


// 次ターン
function nextTurn(){
    if(turnOrder.length===0) return;
    currentUnitIndex++;
    if(currentUnitIndex>=turnOrder.length) currentUnitIndex=0;
    selectedUnit = turnOrder[currentUnitIndex];
    selectedUnit.hasMoved = false;
    selectedUnit.hasAttacked = false;
    renderMap();
updateButtons(); // ここを追加
    if(selectedUnit.type==='enemy') setTimeout(()=>enemyAI(selectedUnit), 500);
}


function enemyAI(unit){
    let targets = units.filter(u=>u.type==='ally');
    if(targets.length===0){ addLog('敵全滅！'); return; }
    targets.sort((a,b)=> Math.abs(a.x-unit.x)+Math.abs(a.y-unit.y) - (Math.abs(b.x-unit.x)+Math.abs(b.y-unit.y)));
    const target = targets[0];

    const dist = Math.abs(unit.x - target.x) + Math.abs(unit.y - target.y);
    if(dist <= unit.range){
        attackUnit(unit,target);
    } else {
        // 移動距離内に収まるように調整
        let dx = target.x - unit.x;
        let dy = target.y - unit.y;
        let moveDist = Math.min(unit.move, Math.abs(dx)+Math.abs(dy));
        let moveX = unit.x;
        let moveY = unit.y;

        // 縦横優先で距離内に移動
        if(Math.abs(dx) >= Math.abs(dy)){
            moveX += dx > 0 ? Math.min(dx, unit.move) : Math.max(dx, -unit.move);
        } else {
            moveY += dy > 0 ? Math.min(dy, unit.move) : Math.max(dy, -unit.move);
        }

        if(!map[moveY][moveX] || map[moveY][moveX].type==='ally'){
            moveUnit(unit, moveX, moveY);
        }
    }

    setTimeout(nextTurn,500);
}


document.getElementById('startBtn').addEventListener('click', ()=> {
    document.getElementById('titleScreen').classList.remove('active');
    document.getElementById('gameScreen').classList.add('active');
    createMap();
    placeUnits();
    selectedUnit = turnOrder[currentUnitIndex];
    renderMap();
updateButtons(); // ここを追加

    // 最初のユニットが敵なら自動で行動
    if(selectedUnit.type === 'enemy') {
        setTimeout(() => enemyAI(selectedUnit), 500);
    }
});


document.getElementById('moveBtn').addEventListener('click', ()=>{ actionMode='move'; });
document.getElementById('attackBtn').addEventListener('click', ()=>{ actionMode='attack'; });
document.getElementById('endTurnBtn').addEventListener('click', ()=>{ nextTurn(); });

// マップクリック
document.getElementById('map').addEventListener('click', (e)=>{
    if(!actionMode) return;
    if(!selectedUnit || selectedUnit.type!=='ally') return; // 味方以外は無効
    const cell = e.target;
    if(!cell.classList.contains('cell')) return;
    const x = parseInt(cell.dataset.x);
    const y = parseInt(cell.dataset.y);
    const unit = selectedUnit;
    if(actionMode==='move'){
        if(moveUnit(unit,x,y)) actionMode=null;
    } else if(actionMode==='attack'){
        const target = map[y][x];
        if(target && target.type!==unit.type){
            if(attackUnit(unit,target)) actionMode=null;
        }
    }
});
</script>
</body>
</html>
